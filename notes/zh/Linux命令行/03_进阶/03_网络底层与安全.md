# 🛡️ 网络底层与安全实战

> **常见真实场景**：
> “知道三次握手还不够：抓过包吗？TIME_WAIT 多了会怎样？如何在不重启服务的情况下观测系统和网络（eBPF）？”

本章节将带你从“背诵八股文”进阶到“看穿网络流量”。

## 1. TCP/IP 协议栈实战

### 1.1 三次握手与四次挥手 (Tcpdump 视角)
别只看图，我们要用 `tcpdump` 亲眼看到。

**抓包命令**：
`sudo tcpdump -i eth0 port 80 -n -S` (显示绝对序列号)

**场景复现**：你在另一终端 `curl http://1.2.3.4`

**握手 (Connection Establishment)**:
1.  **SYN**: `Client -> Server` (Flags [S], seq 100) -> 我想连你。
2.  **SYN+ACK**: `Server -> Client` (Flags [S.], seq 200, ack 101) -> 好的，我也想连你。
3.  **ACK**: `Client -> Server` (Flags [.], ack 201) -> 知道了，连接建立。

**挥手 (Connection Termination)**:
1.  **FIN**: `Client -> Server` (Flags [F.], seq 101) -> 我话说完了，挂了。
2.  **ACK**: `Server -> Client` (Flags [.], ack 102) -> 知道了 (此时 Server 还能发数据)。
3.  **FIN**: `Server -> Client` (Flags [F.], seq 201) -> 我也说完了，挂了。
4.  **ACK**: `Client -> Server` (Flags [.], ack 202) -> 好的，再见。

### 1.2 经典面试题：TIME_WAIT vs CLOSE_WAIT

*   **TIME_WAIT**:
    *   **谁产生**：**主动断开连接的一方** (通常是 Client，但在反向代理中 Nginx 是 Client)。
    *   **现象**：`netstat -n | grep TIME_WAIT` 看到几千个。
    *   **原因**：主动关闭方发完最后一个 ACK 后，需要等待 2MSL 时间，确保 Server 收到了 ACK。如果 Server 没收到会重发 FIN，Client 需要在 TIME_WAIT 状态下再次发送 ACK。
    *   **危害**：占用本地端口。如果耗尽，无法建立新连接。
    *   **优化**：开启 `tcp_tw_reuse`。
*   **CLOSE_WAIT**:
    *   **谁产生**：**被动关闭的一方** (Server)。
    *   **现象**：Server 收到了 FIN，回了 ACK，但**没有发送自己的 FIN**。
    *   **原因**：**代码 Bug**。程序逻辑卡住了，没有调用 `close()` 关闭 socket。
    *   **结论**：发现大量 CLOSE_WAIT，直接找开发改代码，不是系统配置问题。

---

## 2. Linux 防火墙：Iptables

虽然有了 `ufw` 和 `firewalld`，但底层依然是 `iptables` (或 nftables)。理解它对理解 Kubernetes 网络至关重要。

### 2.1 四表五链
核心关注 **Filter 表** (过滤) 和 **INPUT 链** (入站)。

### 2.2 常用操作
**查看规则**：`sudo iptables -L -n --line-numbers`

**封锁攻击 IP**：
```bash
sudo iptables -I INPUT -s 192.168.1.100 -j DROP
```
*   `-I INPUT`: 插入到 INPUT 链最前面。
*   `-s`: 来源 IP。
*   `-j DROP`: 动作是丢弃 (对方会超时)，`REJECT` 是拒绝 (对方会收到拒绝包)。

**开放端口**：
```bash
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
```

**删除规则**：
`sudo iptables -D INPUT 1` (删除 INPUT 链第 1 条规则)

---

## 3. 下一代黑科技：eBPF (加分项)

如果面试官问你：“如何在不重新编译内核、不重启服务的情况下，监控所有进程打开了哪些文件？”
答案是：**eBPF (Extended Berkeley Packet Filter)**。

### 3.1 什么是 eBPF？
它是 Linux 内核中的一个**虚拟机**。
*   你可以写一段代码，通过校验后，**安全地注入到内核**中运行。
*   **用途**：高性能网络包处理 (Cilium)、系统观测 (BCC)、安全监控 (Falco)。

### 3.2 BCC 工具集 (实战)
不需要你会写 eBPF C 代码，只需会用 BCC 工具箱。

**安装**：`sudo apt install bpfcc-tools`

**神级工具演示**：
1.  **`execsnoop`**: 实时监控全系统**谁在运行什么命令**。
    *   *场景*：有人偷偷在服务器上挖矿，但他改了 `ps` 命令让你看不到。用 `execsnoop` 直接监控内核系统调用，他无处遁形。
    *   `sudo execsnoop-bpfcc`
2.  **`opensnoop`**: 监控谁在**打开什么文件**。
    *   *场景*：Nginx 启动报错“配置文件找不到”，但没说是哪个文件。用 `opensnoop` 一看便知。
3.  **`tcptop`**: 实时显示 TCP 连接流量排行 (内核级统计，比 netstat 高效)。

> **总结**：在校招中提到 eBPF 和 BCC 工具，会给面试官留下“技术视野开阔、关注前沿技术”的极佳印象。
